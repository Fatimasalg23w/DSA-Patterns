# ğŸ“š Key Algorithms and Patterns

This repository collects some of the most widely used algorithms and patterns in technical interviews and software development. Each section includes a short explanation and common applications.

---

## ğŸ” Sliding Window
- **Idea:** Use a moving window over an array or string to optimize calculations on subranges.  
- **Applications:** Maximum subarray sum, longest substring without repeating characters.  
- **Complexity:** \(O(n)\).

---

## â• Prefix Sum
- **Idea:** Precompute cumulative sums to answer range queries quickly.  
- **Applications:** Subarray sums, cumulative frequency counts.  
- **Complexity:** Preprocessing \(O(n)\), queries \(O(1)\).

---

## ğŸ¯ Two Pointers
- **Idea:** Use two indices moving at different speeds or directions.  
- **Applications:** Pair sum problems, reversing arrays, substring problems.  
- **Complexity:** \(O(n)\).

---

## ğŸ”— Linked List
- **Idea:** Linear structure where each node points to the next.  
- **Applications:** Queue/stack implementations, cycle detection, dynamic data manipulation.  
- **Complexity:** \(O(1)\) for insertion/deletion at ends.

---

## ğŸ“ˆ Monotonic Stack
- **Idea:** Stack that maintains elements in increasing or decreasing order.  
- **Applications:** Next greater/smaller element, histogram problems, interval queries.  
- **Complexity:** \(O(n)\).

---

## â­ Top K Elements
- **Idea:** Find the \(k\) largest/smallest elements using heaps or quickselect.  
- **Applications:** Rankings, recommendations, log analysis.  
- **Complexity:** \(O(n \log k)\).

---

## ğŸ§­ Modified Binary Search
- **Idea:** Variations of binary search for more complex problems.  
- **Applications:** Search in rotated arrays, first/last occurrence, custom conditions.  
- **Complexity:** \(O(\log n)\).

---

## ğŸŒ² Depth-First Search (DFS)
- **Idea:** Explore graphs/trees deeply before backtracking.  
- **Applications:** Cycle detection, tree traversal, backtracking problems.  
- **Complexity:** \(O(V+E)\).

---

## ğŸŒ Breadth-First Search (BFS)
- **Idea:** Explore graphs/trees level by level.  
- **Applications:** Shortest path in unweighted graphs, level-order traversal.  
- **Complexity:** \(O(V+E)\).

---

## ğŸ§© Matrix Traversal
- **Idea:** Traverse matrices in different patterns (DFS/BFS).  
- **Applications:** Counting islands, pathfinding, simulations.  
- **Complexity:** \(O(n \cdot m)\).

---

## ğŸ”„ Backtracking
- **Idea:** Build solutions step by step and backtrack if they fail.  
- **Applications:** Sudoku, combinations, exhaustive search problems.  
- **Complexity:** Exponential in worst case.

---

## ğŸ§® Dynamic Programming Patterns
- **Idea:** Solve problems by breaking them into subproblems and reusing results.  
- **Applications:** Fibonacci, knapsack, longest common subsequence.  
- **Complexity:** \(O(n^2)\) or better depending on the problem.

---

# ğŸš€ Conclusion
These algorithms and patterns form the foundation for solving complex problems efficiently. Mastering their logic and applications is essential for technical interviews and real-world software projects.
